# Constants for the board dimensions
ROWS = 6
COLS = 7

# Constants representing players
EMPTY = 0
PLAYER1 = 1
PLAYER2 = 2

# Function to create an empty Connect 4 board
def create_board():
    return [[EMPTY] * COLS for _ in range(ROWS)]

# Function to drop a piece into the board
def drop_piece(board, col, player):
    for row in range(ROWS-1, -1, -1):
        if board[row][col] == EMPTY:
            board[row][col] = player
            return

# Function to check if a column is valid for dropping a piece
def is_valid_location(board, col):
    return board[0][col] == EMPTY

# Function to get all valid locations for dropping a piece
def get_valid_locations(board):
    return [col for col in range(COLS) if is_valid_location(board, col)]

# Function to check if a player has won
def winning_move(board, player):
    # Check horizontal locations
    for r in range(ROWS):
        for c in range(COLS - 3):
            if board[r][c] == player and board[r][c+1] == player and board[r][c+2] == player and board[r][c+3] == player:
                return True

    # Check vertical locations
    for c in range(COLS):
        for r in range(ROWS - 3):
            if board[r][c] == player and board[r+1][c] == player and board[r+2][c] == player and board[r+3][c] == player:
                return True

    # Check positively sloped diagonals
    for r in range(ROWS - 3):
        for c in range(COLS - 3):
            if board[r][c] == player and board[r+1][c+1] == player and board[r+2][c+2] == player and board[r+3][c+3] == player:
                return True

    # Check negatively sloped diagonals
    for r in range(3, ROWS):
        for c in range(COLS - 3):
            if board[r][c] == player and board[r-1][c+1] == player and board[r-2][c+2] == player and board[r-3][c+3] == player:
                return True

    return False

# Function to evaluate the score of a board state
def evaluate_window(window, player):
    score = 0
    opponent = PLAYER1 if player == PLAYER2 else PLAYER2

    if window.count(player) == 4:
        score += 100
    elif window.count(player) == 3 and window.count(EMPTY) == 1:
        score += 5
    elif window.count(player) == 2 and window.count(EMPTY) == 2:
        score += 2

    if window.count(opponent) == 3 and window.count(EMPTY) == 1:
        score -= 4

    return score

# Function to calculate the overall score of the board
def score_position(board, player):
    score = 0

    # Score horizontal
    for r in range(ROWS):
        for c in range(COLS-3):
            window = board[r][c:c+4]
            score += evaluate_window(window, player)

    # Score vertical
    for c in range(COLS):
        for r in range(ROWS-3):
            window = [board[r+i][c] for i in range(4)]
            score += evaluate_window(window, player)

    # Score positively sloped diagonal
    for r in range(ROWS-3):
        for c in range(COLS-3):
            window = [board[r+i][c+i] for i in range(4)]
            score += evaluate_window(window, player)

    # Score negatively sloped diagonal
    for r in range(ROWS-3):
        for c in range(COLS-3):
            window = [board[r+3-i][c+i] for i in range(4)]
            score += evaluate_window(window, player)

    return score

# Function to check if the board is full
def is_board_full(board):
    return all(board[0][col] != EMPTY for col in range(COLS))

# Function to print the board
def print_board(board):
    for row in board:
        print(row)

# Function to get the best move for the AI using minimax with alpha-beta pruning
def get_best_move(board, depth, alpha, beta, maximizing_player):
    valid_locations = get_valid_locations(board)
    is_terminal_node = is_board_full(board) or winning_move(board, PLAYER1) or winning_move(board, PLAYER2)
    
    if depth == 0 or is_terminal_node:
        if is_terminal_node:
            if winning_move(board, PLAYER2):
                return (None, 100000000000000)
            elif winning_move(board, PLAYER1):
                return (None, -10000000000000)
            else: # Game is over, no more valid moves
                return (None, 0)
        else: # Depth is zero
            return (None, score_position(board, PLAYER2))
    if maximizing_player:
        value = -float('inf')
        best_col = valid_locations[0]
        for col in valid_locations:
            temp_board = [row[:] for row in board]
            drop_piece(temp_board, col, PLAYER2)
            new_score = get_best_move(temp_board, depth-1, alpha, beta, False)[1]
            if new_score > value:
                value = new_score
                best_col = col
            alpha = max(alpha, value)
            if alpha >= beta:
                break
        return best_col, value
    else: # Minimizing player
        value = float('inf')
        best_col = valid_locations[0]
        for col in valid_locations:
            temp_board = [row[:] for row in board]
            drop_piece(temp_board, col, PLAYER1)
            new_score = get_best_move(temp_board, depth-1, alpha, beta, True)[1]
            if new_score < value:
                value = new_score
                best_col = col
            beta = min(beta, value)
            if alpha >= beta:
                break
        return best_col, value

# Main function to play Connect 4
# def play_connect4():
#     board = create_board()
#     print_board(board)
#     game_over = False
#     turn = 0

#     while not game_over:
#         # Player 1's turn
#         if turn % 2 == 0:
#             col = int(input("Player 1 Make your selection (0-6): "))
#             if is_valid_location(board, col):
#                 drop_piece(board, col, PLAYER1)
#                 if winning_move(board, PLAYER1):
#                     print("Player 1 wins!")
#                     game_over = True
#                 turn += 1
#             else:
#                 print("Invalid move. Try again.")
#         # Player 2's turn
#         else:
#             col, minimax_score = get_best_move(board, 4, -float('inf'), float('inf'), True)
#             drop_piece(board, col, PLAYER2)
#             if winning_move(board, PLAYER2):
#                 print("Player 2 wins!")
#                 game_over = True
#             turn += 1
        
#         print_board(board)

#         if is_board_full(board):
#             print("It's a tie!")
#             game_over = True

# play_connect4()
